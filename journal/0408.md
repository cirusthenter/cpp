# Apr 8, 2020
## 独習 C++ 続き

## 第3章 クラス
- const メンバー関数
	- インスタンスを const で宣言したときに (そんなことをする場面があるのか？という感じだが) もゲッターにはアクセスできるようにしておきたい
	- そのとき、メソッドにも const と付けることでコンパイラの警戒を解くことができる

### C++ にもコンストラクタがあるらしい

```
class Animal
{
	std::string name;
	int age;
	
public:
	Animal();
}

Animal::Animal() : age(-1)
{

}

int main()
{
	animal dog;
}
```

- コンストラクタでも、クラス定義の外で書く
- 初期値の設定は、メソッド名書いたあとのブレースの外で
		- メンバー初期化リストなどと呼ぶ
- 初期化リストにないものはデフォルトで初期化される
	- ちゃんと初期化されるので心配しなくていい
- メイン関数の方でブレースとかで初期化する必要は特にない

### デストラクタ
- メモリリーク防止のためにインスタンス使用終了時に呼ぶ関数
- Java と同様定義できるよという話

### 継承
- 継承のやり方

```
class Dog : Animal
{
}
```

### Google の coding standard 読んでみた
#### Structs vs Classes
- 双方の類似性については認めているようである
- ゲッターとセッターくらいしか役割がないようだったら `struct`、そうでなければ `class` を使う
- 迷ったら `class` 
	- If in doubt, make it a `class`.
- ちなみに、C++ ではポインターではなく参照による受け渡しを行えということが書いてあった
- 

### 第3章終了
- なんか頭でっかちな感じの内容だった

## 第4章
### すらすら読んでく
- もう教養の世界
- 5分で流し読み終わった

## 第5章 配列とポインター
### 関数の引数で
- `void function(int array[5]);` も `void function(int* array);` も同じ意味をもつ
- また、その配列のサイズが5である必要もない。ただ2つが等価であるということだけを言いたい
- 配列はポインターに暗黙的に変換できるというだけで、配列自体は配列の型をもっている
- 配列へのポインター型や配列への参照型は普通のポインター型や参照型の宣言とは表記が大きく異なる
	- さっき paiza の問題を解いていてまさにこの問題に捕まった
	- template とかいうものが後々助けてくれるっぽい

### オブジェクトの配列
#### explicit
- コンストラクタの前に explicit を付けると、初期化の値が指定できるようになる

### 動的配列
- きました
- 待ってました
- あとで詳しく紹介するらしい
- `push_back()` と `pop_back()` をよく使う

### 関数へのポインターや関数への参照も存在する

## この本は全体的に定義をきちんと述べない節があるのが気になる
- 「〜のような困った場面があります。こんなときは〇〇の出番です。〜〜のような恩恵を受けることができます」という表現が非常に多い
	- これはフレンドリーな書き方をしているようでなかなかに分かりづらい
	- なぜなら定義を述べずに誤魔化しているから
- はっきりと語の定義を述べるべき
	- この単語はこういう意味です！って言い切る
	- 自分が書くときは気をつける


## 第7章 演算子オーバーロード
- この章は必要ないだろうな
- いつかやろう
